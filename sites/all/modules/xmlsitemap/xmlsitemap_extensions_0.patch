From 8118bac7e1546b3cd70d5e023e5df3e6f4c25d51 Mon Sep 17 00:00:00 2001
From: Liem Khuu <liem@imagewks.com>
Date: Tue, 5 Jun 2012 13:51:15 -0400
Subject: [PATCH 1/2] Added XML element extension classes, which could allow
 another module to provide custom image,video,new,
 etc... handling

---
 xmlsitemap.elements.inc   |  300 +++++++++++++++++++++++++++++++++++++++++++++
 xmlsitemap.generate.inc   |   54 ++-------
 xmlsitemap.info           |    1 +
 xmlsitemap.module         |   31 +++++
 xmlsitemap.xmlsitemap.inc |   11 ++-
 5 files changed, 353 insertions(+), 44 deletions(-)
 create mode 100644 xmlsitemap.elements.inc

diff --git a/xmlsitemap.elements.inc b/xmlsitemap.elements.inc
new file mode 100644
index 0000000..70b980a
--- /dev/null
+++ b/xmlsitemap.elements.inc
@@ -0,0 +1,300 @@
+<?php
+/**
+ * @file xmlsitemap_elements.inc
+ *  Interfaces and classes to handle writing individual XMLSitemap element entries.
+ */
+
+/**
+ * Base interface for classes that can be used to write XMLSitemap
+ *  links to a document. 
+ *  
+ *  Note: It is more likely that someone will want
+ *  to use the default base class, but all uses of this class should
+ *  refer to the interface in case the implementation needs to be 
+ *  drastically different from what the default base class provides. 
+ */
+interface IXMLSitemapElement {
+  
+  /**
+   * Returns whether or not this element has any content.
+   */
+  function hasEntries();
+  
+  /**
+   * Converts raw data that you would get from a database query
+   *  into data that can be rendered by $this->writeElement()
+   * 
+   * @param $raw
+   *  A database dump of the data.
+   */
+  function formatData($raw);
+  
+  /**
+   * Writes the full data set of XML data to an XMLWriter object.
+   *  This should include any extensions or included data if relevant.
+   * 
+   * @param XMLWriter $writer
+   *  XMLWriter object that connects to the output destination.
+   */
+  function writeElement(XMLWriter $writer);
+}
+
+/**
+ * Base interface for classes that can be used to write XMLSitemap
+ *  extended data. The note above also applies here.
+ */
+interface IXMLSitemapExtensionElement extends IXMLSitemapElement {
+  
+  /**
+   * The extension class is responsible of retrieving its required data
+   *  base solely on the XMLSitemap link being rendered.
+   *  
+   * @param $link
+   *  A full XMLSitemap link data in array form.
+   */
+  function fetchExtensionData($link);
+}
+
+/**
+ * The default base class for rendering a single sitemap element.
+ * - This class takes over the duty of formatting the sitemap link
+ * - Allowing attachement of extension data
+ * - Rendering a the link to XML including extension data attached.
+ */
+class XMLSitemapElement implements IXMLSitemapElement  {
+  protected $link;
+  protected $options;
+  
+  protected $entry;
+  protected $extensions;
+  
+  /**
+   * Create a new XMLSitemap element representing a link.
+   * 
+   * @param $link
+   *  The XMLSitemap link to render.
+   * @param $options
+   *  Array of link formatting options to use.
+   */
+  function __construct($link, $options) {
+    if (!empty($link)) {
+      $this->link = $link;
+      $this->options = $options;
+      $entry = $this->formatData($link);
+      $this->extensions = array();
+    }
+  }
+  
+  /**
+   * (non-PHPdoc)
+   * @see IXMLSitemapElement::hasEntries()
+   */
+  function hasEntries() {
+    return !empty($this->entry);
+  }
+  
+  /**
+   * (non-PHPdoc)
+   * @see IXMLSitemapElement::formatData()
+   */
+  function formatData($link) {
+    static $last_url;
+    static $lastmod_format;
+
+    if (!isset($lastmod_format)) {
+      $lastmod_format = variable_get('xmlsitemap_lastmod_format', XMLSITEMAP_LASTMOD_MEDIUM);
+    }
+    
+    $link['language'] = $link['language'] != LANGUAGE_NONE ? xmlsitemap_language_load($link['language']) : $this->options['language'];
+    if ($this->options['alias']) {
+      $link['loc'] = xmlsitemap_get_path_alias($link['loc'], $link['language']->language);
+    }
+    
+    $link_options = array(
+      'language' => $link['language'],
+      'xmlsitemap_link' => $link,
+      'xmlsitemap_sitemap' => isset($sitemap) ? $sitemap : NULL,
+    );
+    // @todo Add a separate hook_xmlsitemap_link_url_alter() here?
+    $link_url = url($link['loc'], $link_options + $this->options);
+    
+    // Skip this link if it was a duplicate of the last one.
+    // @todo Figure out a way to do this before generation so we can report
+    // back to the user about this.
+    if ($link_url == $last_url) {
+      return;
+    }
+    $last_url = $link_url;
+    
+    $element = array();
+    $element['loc'] = $link_url;
+    if ($link['lastmod']) {
+      $element['lastmod'] = gmdate($lastmod_format, $link['lastmod']);
+      // If the link has a lastmod value, update the changefreq so that links
+      // with a short changefreq but updated two years ago show decay.
+      // We use abs() here just incase items were created on this same cron run
+      // because lastmod would be greater than REQUEST_TIME.
+      $link['changefreq'] = (abs(REQUEST_TIME - $link['lastmod']) + $link['changefreq']) / 2;
+    }
+    if ($link['changefreq']) {
+      $element['changefreq'] = xmlsitemap_get_changefreq($link['changefreq']);
+    }
+    if (isset($link['priority']) && $link['priority'] != 0.5) {
+      // Don't output the priority value for links that have 0.5 priority. This
+      // is the default 'assumed' value if priority is not included as per the
+      // sitemaps.org specification.
+      $element['priority'] = number_format($link['priority'], 1);
+    }
+    return $element;
+  }
+  
+  /**
+   * (non-PHPdoc)
+   * @see IXMLSitemapElement::writeElement()
+   */
+  function writeElement(XMLWriter $writer) {
+    // write itself first
+    foreach ($this->entry as $name => $content) {
+      $this->writeInnerElement($name, $content, $writer);
+    }
+    
+    // then write extension data.
+    foreach ($this->extensions as $extension) {
+      $extension->writeElement($writer);
+    }
+  }
+  
+  /**
+   * Internal function for writing XML elements.
+   * 
+   * @param $name
+   *  Of the XML element to write (tag name).
+   * @param $content
+   *  Either an array of sub-elements to write or a string of text
+   *  content to write out to the document.  
+   * @param $writer
+   *  The document writer to use for writing out the element data.
+   */
+  protected function writeInnerElement($name, $content, XMLWriter $writer) {
+    $writer->startElement($name);
+ 
+    if (is_array($content)) {
+      foreach ($content as $sub_name => $sub_content) {
+        $this->writeInnerElement($sub_name, $sub_content);
+      }
+    }
+    else {
+      $writer->text($content);
+    }
+    $writer->endElement();
+    $writer->writeRaw(PHP_EOL);
+  }
+  
+  /**
+   * Creates and instance of valid extension classes and populates
+   *  them with data, for preparation to write the results out.
+   * 
+   * @param $extension
+   *  Name of the extension class to try including with this link.
+   */
+  function addExtensionData($extension) {
+    // First we need to determine if this is a valid extension class
+    if (is_string($extension)) {
+      $reflect = new ReflectionClass($extension);
+      if ($reflect->implementsInterface('IXMLSitemapExtensionElement')) {
+        $extender = $reflect->newInstance($this->link);
+        
+        // Only add the extension if there is extension data for this link.
+        if ($extender->hasEntries()) {
+          $this->extensions[] = $extender;
+        }
+      }
+    }
+  }
+}
+
+/**
+ * Default base class for XMLSitemap extension elements.
+ *  These are used to add data to the sitemap outside of the core
+ *  protocol.
+ */
+abstract class XMLSitemapExtensionElement implements IXMLSitemapExtensionElement {
+  protected $link;    // XML Sitemap link to generate
+  protected $entries; // Data retrieved for associated videos
+  
+  // abstract functions handle extension specific items.
+  abstract function getNS();        // The namespace used by this extension
+  abstract function getWrapper();   // The wrapper element name for this extension.
+  
+  function __construct($link) {
+    $entries = array();
+    if (!empty($link)) {
+      $this->link = $link;
+      $this->fetchExtensionData($link);
+    }
+  }
+  
+  /**
+   * (non-PHPdoc)
+   * @see IXMLSitemapElement::hasEntries()
+   */
+  function hasEntries() {
+    return !empty($this->entries);
+  }
+  
+  /**
+   * (non-PHPdoc)
+   * @see IXMLSitemapElement::writeElement()
+   */
+  function writeElement(XMLWriter $writer) {
+    if (empty($this->entries)) {
+      return;
+    }
+    
+    foreach ($this->entries as $elements) {
+      $writer->startElementNs($this->getNS(), $this->getWrapper(), NULL);
+      $writer->writeRaw(PHP_EOL);
+      foreach ($elements as $name => $element) {
+        $this->writeInnerElement($name, $element, $writer);
+      }
+      $writer->endElement();
+      $writer->writeRaw(PHP_EOL);
+    }
+  }
+  
+  /**
+   * Writes internal elements within the extension element
+   *  I.E. all the elements between <video:video> and </video:video>.
+   *  It is a little bit different from the XMLSitemapElement version
+   *  because it expects element data (text/children) to be array form
+   *  so that attributes can be added to the tag.
+   * 
+   * @param $name
+   *  Name of the XML tag.
+   * @param $element
+   *  The element attributes and content.
+   * @param XMLWriter $writer
+   *  XMLWriter to output the XML to.
+   */
+  protected function writeInnerElement($name, $element, XMLWriter $writer) {
+    $writer->startElementNs($this->getNS(), $name, NULL);
+  
+    // Write additional attributes if required.
+    if (!empty($element['#attributes'])) {
+      foreach ($element['#attributes'] as $attr_name => $attr_value) {
+        $writer->writeAttribute($attr_name, $attr_value);
+      }
+    }
+  
+    if (is_array($element['#data'])) {
+      foreach ($element['#data'] as $key => $child) {
+        $this->writeInnerElement($key, $child, $writer);
+      }
+    }
+    elseif (!empty($element['#data']) && is_string($element['#data'])) {
+      $writer->text($element['#data']);
+    }
+    $writer->endElement();
+    $writer->writeRaw(PHP_EOL);
+  }
+}
\ No newline at end of file
diff --git a/xmlsitemap.generate.inc b/xmlsitemap.generate.inc
index c6b564a..d744c3d 100644
--- a/xmlsitemap.generate.inc
+++ b/xmlsitemap.generate.inc
@@ -163,49 +163,19 @@ function xmlsitemap_generate_chunk(stdClass $sitemap, XMLSitemapWriter $writer,
   $query->range($offset, $limit);
   $links = $query->execute();
 
+  $extensions = xmlsitemap_get_extensions();
   while ($link = $links->fetchAssoc()) {
-    $link['language'] = $link['language'] != LANGUAGE_NONE ? xmlsitemap_language_load($link['language']) : $url_options['language'];
-    if ($url_options['alias']) {
-      $link['loc'] = xmlsitemap_get_path_alias($link['loc'], $link['language']->language);
-    }
-    $link_options = array(
-      'language' => $link['language'],
-      'xmlsitemap_link' => $link,
-      'xmlsitemap_sitemap' => $sitemap,
-    );
-    // @todo Add a separate hook_xmlsitemap_link_url_alter() here?
-    $link_url = url($link['loc'], $link_options + $url_options);
-
-    // Skip this link if it was a duplicate of the last one.
-    // @todo Figure out a way to do this before generation so we can report
-    // back to the user about this.
-    if ($link_url == $last_url) {
-      continue;
-    }
-    else {
-      $last_url = $link_url;
-      // Keep track of the total number of links written.
-      $link_count++;
-    }
-
-    $element = array();
-    $element['loc'] = $link_url;
-    if ($link['lastmod']) {
-      $element['lastmod'] = gmdate($lastmod_format, $link['lastmod']);
-      // If the link has a lastmod value, update the changefreq so that links
-      // with a short changefreq but updated two years ago show decay.
-      // We use abs() here just incase items were created on this same cron run
-      // because lastmod would be greater than REQUEST_TIME.
-      $link['changefreq'] = (abs(REQUEST_TIME - $link['lastmod']) + $link['changefreq']) / 2;
-    }
-    if ($link['changefreq']) {
-      $element['changefreq'] = xmlsitemap_get_changefreq($link['changefreq']);
-    }
-    if (isset($link['priority']) && $link['priority'] != 0.5) {
-      // Don't output the priority value for links that have 0.5 priority. This
-      // is the default 'assumed' value if priority is not included as per the
-      // sitemaps.org specification.
-      $element['priority'] = number_format($link['priority'], 1);
+    $element = new XMLSitemapElement($link, $url_options);
+
+    // The newly created object will contain a flag indicating if it contains
+    // actual data that can be written.
+    if ($element->hasEntries() && !empty($extensions['types'][$link['type']])) {
+      $extenders = $extensions['types'][$link['type']];
+      foreach ($extenders as $class => $file) {
+        require_once($file);
+        $element->addExtensionData($class);
+      }
+      ++$link_count;
     }
     $writer->writeSitemapElement('url', $element);
   }
diff --git a/xmlsitemap.info b/xmlsitemap.info
index ed31403..a3936e7 100644
--- a/xmlsitemap.info
+++ b/xmlsitemap.info
@@ -7,6 +7,7 @@ files[] = xmlsitemap.inc
 files[] = xmlsitemap.admin.inc
 files[] = xmlsitemap.drush.inc
 files[] = xmlsitemap.generate.inc
+files[] = xmlsitemap.elements.inc
 files[] = xmlsitemap.xmlsitemap.inc
 files[] = xmlsitemap.pages.inc
 files[] = xmlsitemap.install
diff --git a/xmlsitemap.module b/xmlsitemap.module
index 34f3f8c..aac3f96 100644
--- a/xmlsitemap.module
+++ b/xmlsitemap.module
@@ -371,6 +371,37 @@ function xmlsitemap_sitemap_load_multiple($smids = array(), array $conditions =
   return $sitemaps;
 }
 
+/**
+ * @param $reset
+ */
+function xmlsitemap_get_extensions($reset = FALSE) {
+  $info = &drupal_static(__FUNCTION__, NULL, $reset);
+
+  if (!isset($info)) {
+    $info = array('namespace' => array(), 'types' => array());
+
+    // Iterate through supported extensions and add namespaces and handlers accordingly.
+    foreach (module_implements('xmlsitemap_extension_info') as $module) {
+      $ext = module_invoke($module, 'xmlsitemap_extension_info');
+      foreach ($ext as $name => $values) {
+        if (!empty($values['namespace']) && is_array($values['namespace'])) {
+          foreach ($values['namespace'] as $ns => $source) {
+            if (preg_match('/^xmlns:[a-z]+$/i', $ns) > 0) {
+              $info['namespace'][$ns] = drupal_strip_dangerous_protocols($source);
+            }
+          }
+        }
+        if (is_array($values['types'])) {
+          foreach ($values['types'] as $type) {
+            $info['types'][$type][$values['class']] = $values['file'];
+          }
+        }
+      }
+    }
+  }
+  return $info;
+}
+
 /**
  * Load an XML sitemap array from the database based on its context.
  *
diff --git a/xmlsitemap.xmlsitemap.inc b/xmlsitemap.xmlsitemap.inc
index 46ab406..5a48bf5 100644
--- a/xmlsitemap.xmlsitemap.inc
+++ b/xmlsitemap.xmlsitemap.inc
@@ -70,6 +70,11 @@ class XMLSitemapWriter extends XMLWriter {
       $attributes['xmlns:xsi'] = 'http://www.w3.org/2001/XMLSchema-instance';
       $attributes['xsi:schemaLocation'] = 'http://www.sitemaps.org/schemas/sitemap/0.9 http://www.sitemaps.org/schemas/sitemap/0.9/sitemap.xsd';
     }
+
+    // Add necessary namespaces for extensions to the XML sitemap.
+    $extensions = xmlsitemap_get_extensions();
+    $attributes += $extensions['namespace'];
+
     return $attributes;
   }
 
@@ -96,8 +101,10 @@ class XMLSitemapWriter extends XMLWriter {
    * @param $element
    *   An array of the elements properties and values.
    */
-  public function writeSitemapElement($name, array &$element) {
-    $this->writeElement($name, $element);
+  public function writeSitemapElement($wrapper, IXMLSitemapElement &$element) {
+    $this->startElement($wrapper);
+    $element->writeElement($this);
+    $this->endElement();
     $this->writeRaw(PHP_EOL);
 
     // After a certain number of elements have been added, flush the buffer
-- 
1.7.5.4


From 6e44cf6d69f66b82e528b9a1c690b5664a2296f7 Mon Sep 17 00:00:00 2001
From: Liem Khuu <liem@imagewks.com>
Date: Tue, 5 Jun 2012 16:07:51 -0400
Subject: [PATCH 2/2] some bug fixes for the new site map elements

---
 xmlsitemap.elements.inc |   33 ++++++++++++++++++++-------------
 xmlsitemap.generate.inc |    8 +++-----
 2 files changed, 23 insertions(+), 18 deletions(-)

diff --git a/xmlsitemap.elements.inc b/xmlsitemap.elements.inc
index 70b980a..110203d 100644
--- a/xmlsitemap.elements.inc
+++ b/xmlsitemap.elements.inc
@@ -80,7 +80,7 @@ class XMLSitemapElement implements IXMLSitemapElement  {
     if (!empty($link)) {
       $this->link = $link;
       $this->options = $options;
-      $entry = $this->formatData($link);
+      $this->entry = $this->formatData($link);
       $this->extensions = array();
     }
   }
@@ -198,18 +198,25 @@ class XMLSitemapElement implements IXMLSitemapElement  {
    *  Name of the extension class to try including with this link.
    */
   function addExtensionData($extension) {
-    // First we need to determine if this is a valid extension class
-    if (is_string($extension)) {
-      $reflect = new ReflectionClass($extension);
-      if ($reflect->implementsInterface('IXMLSitemapExtensionElement')) {
-        $extender = $reflect->newInstance($this->link);
-        
-        // Only add the extension if there is extension data for this link.
-        if ($extender->hasEntries()) {
-          $this->extensions[] = $extender;
-        }
+  	static $reflect;
+
+  	if (!isset($refect)) {
+  		$reflect = array();
+  	}
+
+    // Determine if this extension name has already been checked. 
+  	if (!isset($reflect[$extension]) && is_string($extension)) {
+      $ext = new ReflectionClass($extension);
+      $reflect[$extension] = $ext->implementsInterface('IXMLSitemapExtensionElement') ? $ext : NULL;
+  	}
+
+  	// If extension is available, create and attempt to add it if there is relevant data.
+  	if (!empty($reflect[$extension])) {  		
+  		$extender = $reflect[$extension]->newInstance($this->link);
+      if ($extender->hasEntries()) {
+        $this->extensions[] = $extender;
       }
-    }
+  	}
   }
 }
 
@@ -227,7 +234,7 @@ abstract class XMLSitemapExtensionElement implements IXMLSitemapExtensionElement
   abstract function getWrapper();   // The wrapper element name for this extension.
   
   function __construct($link) {
-    $entries = array();
+    $this->entries = array();
     if (!empty($link)) {
       $this->link = $link;
       $this->fetchExtensionData($link);
diff --git a/xmlsitemap.generate.inc b/xmlsitemap.generate.inc
index d744c3d..c2644f0 100644
--- a/xmlsitemap.generate.inc
+++ b/xmlsitemap.generate.inc
@@ -150,7 +150,7 @@ function xmlsitemap_generate_chunk(stdClass $sitemap, XMLSitemapWriter $writer,
   $link_count = 0;
 
   $query = db_select('xmlsitemap', 'x');
-  $query->fields('x', array('loc', 'lastmod', 'changefreq', 'changecount', 'priority', 'language', 'access', 'status'));
+  $query->fields('x', array('id', 'type', 'loc', 'lastmod', 'changefreq', 'changecount', 'priority', 'language', 'access', 'status'));
   $query->condition('x.access', 1);
   $query->condition('x.status', 1);
   $query->orderBy('x.language', 'DESC');
@@ -167,19 +167,17 @@ function xmlsitemap_generate_chunk(stdClass $sitemap, XMLSitemapWriter $writer,
   while ($link = $links->fetchAssoc()) {
     $element = new XMLSitemapElement($link, $url_options);
 
-    // The newly created object will contain a flag indicating if it contains
-    // actual data that can be written.
+    // The newly created object will contain a flag indicating if it
+    // contains actual data that can be written.
     if ($element->hasEntries() && !empty($extensions['types'][$link['type']])) {
       $extenders = $extensions['types'][$link['type']];
       foreach ($extenders as $class => $file) {
-        require_once($file);
         $element->addExtensionData($class);
       }
       ++$link_count;
     }
     $writer->writeSitemapElement('url', $element);
   }
-
   return $link_count;
 }
 
-- 
1.7.5.4

